const InverseMap = Dict{Symbol, Symbol}
const Gens{N} = NTuple{N, Symbol} where N
const Maybe{T} = Union{Nothing, T}
struct Id end
const GenList = Vector{Pair{Symbol,Symbol}}
abstract type  Group end  

struct FreeGroup<:Group 
    gens::Gens
    invs::Gens
    cfg::GroupConfig
    function FreeGroup(g_list::GenList) 
        g_list |> flatten |> collect |> 
            v-> !isempty(v∩fieldnames(FreeGroup)) && 
                error("Invalid generator names $(fieldnames(FreeGroup)∩v))")
        g = g_list |> Tuple
        

        new(
            Base.Fix2(getfield, :first).(g), 
            Base.Fix2(getfield, :second).(g),
            cfg
        )
    end
end

Base.:<(F1::G, F2::G) where G<:Group = F1.gens ⊆ F2.gens

gen_list(pv::Vector{Symbol}) = GenList([sym=>inv_symbol(sym, cfg.inv_symbol) for sym in pv])





function gen_symbol(F1::Group, S::Union{Id, Symbol}, inverse::Bool = false) 
    S===Id() && return Id()
    gen_inv = filter(x->S∈x, zip(F1.gens, F1.invs)|>collect) |> only
    !inverse ? gen_inv[1] : gen_inv[2]
end



function Base.getproperty(F::G, name::Symbol) where G<:Group
    name∈fieldnames(G) ? Base.getfield(F, name) : F(name)
end


macro freeGroup(vars::Symbol...)
    :(FreeGroup(gen_list($([v for v in vars]))))
end

    


macro freeGroup(vars::Expr)
    map(filter(v->!isa(v, LineNumberNode), vars.args)) do x
        x.args[1] === :(=>) || error("Invalid expression $x in free group definition")
        x.args[2] => x.args[3]
    end |> FreeGroup
end
###


Base.in(g::Symbol, F::Group) = (g∈F.gens || g∈F.invs) 

### GenDefs
    struct Gen{G<:Group}   
        Group::G
        name::Union{Symbol, Id}
        value::Integer 
        Gen(F::G, ::Id) where G<:Group = new{G}(F, Id(), 0)
        
        function Gen(F::G, name::Symbol, value::Integer)  where {G<:Group}
            value==0 && return Gen(F, Id())
            i = name ∈ F.gens ? value : 
                name ∈ F.invs ? -value :
                error("symbol not defining a generator")
            new{G}(F,gen_symbol(F, name), i)
        end  
    end

    Gen(F::G,name::Symbol) where G<:Group = Gen(F, name, 1)
    Gen(F::G,gen::Gen{G}) where G<:Group = Gen(F, gen.name, gen.value)

    function Base.:*(x::GrpElem{G}, y::GrpElem{G})::GrpElem{G} where G<:Group
        y.Group<x.Group || error("$(y.Group) is not a subgroup of $(x.Group)")
        elem_x = GrpElem(x)
        push!(elem_x, y)
        elem_x
    end

    function Base.:/(x::Gen{G}, y::Gen{G})::GrpElem{G} where G<:Group
        x*inv(y)
    end

    function (F::G where G<:Group)(args...)
        Gen(F, args...)
    end

    Base.:^(x::Gen, p::Integer) = x.Group(x.name, p*x.value)
    Base.inv(x::Gen) = x.Group(x.name, -1*x.value)

###

function parseString(s::String, F::G)::Vector{Gen{G}} where G<:Group
    match(r"^1$|^\s*$|^$", s)===nothing || return F()
    elem_matches = eachmatch(r"(?<name>[^\d|\s][^\^]*)(?:\^(?<value>\d))?", s)
    length(elem_matches)==1 ? 
        let x=only(elem_matches); [F(x[:name], x[:value])] end : 
        [F(Symbol(m[:name]), Intger(m[:value])) for m in elem_matches]
end

mutable struct GrpElem{G<:Group} 
    Group::G
    front::Union{Id, Vector{Gen{G}}}
    final::Union{Id, Gen{G}}
end

GrpElem(F::G) where G<:Group = GrpElem{G}(F, Id(), F())
GrpElem(X::Gen{G}) where G<:Group = GrpElem{G}(X.Group, Id(), X)

Base.convert(::Type{GrpElem{G}}, x::Gen{G}) where G<:Group = GrpElem(x)
function GrpElem(F::G, s::String) where G<:Group
    gens = parseString(s,F)
    id = GrpElem(F)
    for g in gens
        push!(id,g)
    end
end

function Base.sizeof(x::GrpElem{G}) where G<:Group
    x.front===Id() || return sizeof(x.front)+1 

    x.final===Id() ? 0 : 1
end


function Base.push!(x::GrpElem{G}, g::Gen{G})::GrpElem{G} where G<:Group
    x_end = x.final
    @match (x_end.name, g.name) begin
        (Id(), _) => GrpElem(g)
        (_, Id()) => x
        (t, t) => x.value==y.value ? x.final = popfirst!(x.front) : x.final = x.Group(t, x.value+y.value)
        (_,_) =>  begin 
            x.front==Id() ? setfield!(x, :front, [x.final]) : push!(x.front, x.final) 
            setfield!(x, :final, g) 
        end
    end
end

Base.eltype(::Type{GrpElem{G}}) where G<:Group = Gen{G}
Base.iterate(x::GrpElem{G}) where G<:Group = flatten((x.front, x.final))
Base.length(x::GrpElem{G}) where G<:Group = sizeof(x)
    

function generator_list(F::G, inverse::Bool=false) where G<:Group
    map(F.gens) do sym 
        inverse ? inv(F(sym)) : F(sym)
    end 
end

gen_format(x::Gen{G}) where G<:Group = "$(gen_symbol(x.Group, x.name, x.value<0))^$(abs(x.value))"

function Base.show(io::IO, x::Gen{G}) where G
    print(io, "Generator: $(gen_symbol(x.Group, x.name, x.value<0))^$(abs(x.value))")
end
Base.show(io::IO, ::Id) = print(io, "Element: 1")
Base.show(io::IO, F::FreeGroup) = print(io, "Free group on $(length(F.gens)) generators generated by $(F.gens)")

function Base.show(io::IO, y::GrpElem{G}) where G
    print(io, join(gen_format.([(y.front)..., y.final]), cfg.element_sep))
end
# function Base.show(io::IO, ::MIME"text/plain", y::GroupElem)
#     element = reduce(Base.:*, map(x-> "$(x.value>0 ? x.key : inv_map[x.key])"*"$(abs(x.value) ≠ 1 ? x.value : "")", y.elems), init="")
#     print(io, "Element: $element")
# end












